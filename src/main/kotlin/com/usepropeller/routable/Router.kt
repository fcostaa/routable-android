/*
    Routable for Android
    Copyright (c) 2013 Turboprop, Inc. <clay@usepropeller.com>
    http://usepropeller.com

    Licensed under the MIT License.

    Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/

package com.usepropeller.routable

import java.net.URI
import java.util.HashMap
import kotlin.collections.Map.Entry

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle

import org.apache.http.NameValuePair
import org.apache.http.client.utils.URLEncodedUtils

class Router {

    /**
     * The class used when you want to map a function (given in `run`)
     * to a Router URL.
     */
    abstract class RouterCallback {
        abstract fun run(context: RouteContext)
    }

    /**
     * The class supplied to custom callbacks to describe the route route
     */
    inner class RouteContext(params: Map<String, String>, extras: Bundle, context: Context) {
        /**
         * Returns the route parameters as specified by the configured route
         */
        var params: Map<String, String>
            internal set
        /**
         * Returns the extras supplied with the route
         */
        var extras: Bundle
            internal set
        /**
         * Returns the Android Context that should be used to open the route
         */
        var context: Context
            internal set

        init {
            this.params = params
            this.extras = extras
            this.context = context
        }
    }

    /**
     * The class used to determine behavior when opening a URL.
     * If you want to extend Routable to handle things like transition
     * animations or fragments, this class should be augmented.
     */
    class RouterOptions {
        var openClass: Class<out Activity>
        var callback: RouterCallback? = null
        var defaultParams: Map<String, String>? = null

        constructor() {

        }

        constructor(klass: Class<out Activity>) {
            this.openClass = klass
        }

        constructor(defaultParams: Map<String, String>) {
            this.defaultParams = defaultParams
        }

        constructor(defaultParams: Map<String, String>, klass: Class<out Activity>) {
            this.defaultParams = defaultParams
            this.openClass = klass
        }
    }

    private class RouterParams {
        var routerOptions: RouterOptions? = null
        var openParams: MutableMap<String, String>? = null
    }

    private val _routes = HashMap<String, RouterOptions>()
    /**
     * @return The router's root URL, or null.
     */
    /**
     * Set the root url; used when opening an activity or callback via RouterActivity
     * @param rootUrl The URL format to use as the root
     */
    var rootUrl: String? = null
    private val _cachedRoutes = HashMap<String, RouterParams>()
    /**
     * @return The context for the router
     */
    /**
     * @param context [Context] that all [Intent]s generated by the router will use
     */
    var context: Context? = null

    /**
     * Creates a new Router
     */
    constructor() {

    }

    /**
     * Creates a new Router
     * @param context [Context] that all [Intent]s generated by the router will use
     */
    constructor(context: Context) {
        this.context = context
    }

    /**
     * Map a URL to a callback
     * @param format The URL being mapped; for example, "users/:id" or "groups/:id/topics/:topic_id"
     * *
     * @param callback [RouterCallback] instance which contains the code to execute when the URL is opened
     */
    fun map(format: String, callback: RouterCallback) {
        val options = RouterOptions()
        options.callback = callback
        this.map(format, null, options)
    }

    /**
     * Map a URL to open an [Activity]
     * @param format The URL being mapped; for example, "users/:id" or "groups/:id/topics/:topic_id"
     * *
     * @param klass The [Activity] class to be opened with the URL
     */
    fun map(format: String, klass: Class<out Activity>) {
        this.map(format, klass, null)
    }

    /**
     * Map a URL to open an [Activity]
     * @param format The URL being mapped; for example, "users/:id" or "groups/:id/topics/:topic_id"
     * *
     * @param klass The [Activity] class to be opened with the URL
     * *
     * @param options The [RouterOptions] to be used for more granular and customized options for when the URL is opened
     */
    fun map(format: String, klass: Class<out Activity>?, options: RouterOptions?) {
        var options = options
        if (options == null) {
            options = RouterOptions()
        }
        options.openClass = klass
        this._routes.put(format, options)
    }

    /**
     * Open a URL using the operating system's configuration (such as opening a link to Chrome or a video to YouTube)
     * @param url The URL; for example, "http://www.youtube.com/watch?v=oHg5SJYRHA0"
     */
    fun openExternal(url: String) {
        this.openExternal(url, this.context)
    }

    /**
     * Open a URL using the operating system's configuration (such as opening a link to Chrome or a video to YouTube)
     * @param url The URL; for example, "http://www.youtube.com/watch?v=oHg5SJYRHA0"
     * *
     * @param context The context which is used in the generated [Intent]
     */
    fun openExternal(url: String, context: Context) {
        this.openExternal(url, null, context)
    }

    /**
     * Open a URL using the operating system's configuration (such as opening a link to Chrome or a video to YouTube)
     * @param url The URL; for example, "http://www.youtube.com/watch?v=oHg5SJYRHA0"
     * *
     * @param extras The [Bundle] which contains the extras to be assigned to the generated [Intent]
     */
    fun openExternal(url: String, extras: Bundle) {
        this.openExternal(url, extras, this.context)
    }

    /**
     * Open a URL using the operating system's configuration (such as opening a link to Chrome or a video to YouTube)
     * @param url The URL; for example, "http://www.youtube.com/watch?v=oHg5SJYRHA0"
     * *
     * @param extras The [Bundle] which contains the extras to be assigned to the generated [Intent]
     * *
     * @param context The context which is used in the generated [Intent]
     */
    fun openExternal(url: String, extras: Bundle?, context: Context?) {
        if (context == null) {
            throw ContextNotProvided(
                    "You need to supply a context for Router " + this.toString())
        }
        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
        this.addFlagsToIntent(intent, context)
        if (extras != null) {
            intent.putExtras(extras)
        }
        context.startActivity(intent)
    }

    /**
     * Open a map'd URL set using [.map] or [.map]
     * @param url The URL; for example, "users/16" or "groups/5/topics/20"
     */
    fun open(url: String) {
        this.open(url, this.context)
    }

    /**
     * Open a map'd URL set using [.map] or [.map]
     * @param url The URL; for example, "users/16" or "groups/5/topics/20"
     * *
     * @param extras The [Bundle] which contains the extras to be assigned to the generated [Intent]
     */
    fun open(url: String, extras: Bundle) {
        this.open(url, extras, this.context)
    }

    /**
     * Open a map'd URL set using [.map] or [.map]
     * @param url The URL; for example, "users/16" or "groups/5/topics/20"
     * *
     * @param context The context which is used in the generated [Intent]
     */
    fun open(url: String, context: Context) {
        this.open(url, null, context)
    }

    /**
     * Open a map'd URL set using [.map] or [.map]
     * @param url The URL; for example, "users/16" or "groups/5/topics/20"
     * *
     * @param extras The [Bundle] which contains the extras to be assigned to the generated [Intent]
     * *
     * @param context The context which is used in the generated [Intent]
     */
    fun open(url: String, extras: Bundle?, context: Context?) {
        if (context == null) {
            throw ContextNotProvided(
                    "You need to supply a context for Router " + this.toString())
        }
        val params = this.paramsForUrl(url)
        val options = params.routerOptions
        if (options!!.callback != null) {
            val routeContext = RouteContext(params.openParams, extras, context)

            options.callback!!.run(routeContext)
            return
        }

        val intent = this.intentFor(context, params) ?: // Means the options weren't opening a new activity
                return
        if (extras != null) {
            intent.putExtras(extras)
        }
        context.startActivity(intent)
    }

    /*
	 * Allows Intents to be spawned regardless of what context they were opened with.
	 */
    private fun addFlagsToIntent(intent: Intent, context: Context) {
        if (context === this.context) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
    }

    /**
     * @param url The URL; for example, "users/16" or "groups/5/topics/20"
     * *
     * @return The [Intent] for the url
     */
    fun intentFor(url: String): Intent {
        val params = this.paramsForUrl(url)

        return intentFor(params)
    }

    private fun intentFor(params: RouterParams): Intent {
        val options = params.routerOptions
        val intent = Intent()
        if (options!!.defaultParams != null) {
            for ((key, value) in options.defaultParams!!) {
                intent.putExtra(key, value)
            }
        }
        for ((key, value) in params.openParams!!) {
            intent.putExtra(key, value)
        }
        return intent
    }

    /**
     * @param url The URL to check
     * *
     * @return Whether or not the URL refers to an anonymous callback function
     */
    fun isCallbackUrl(url: String): Boolean {
        val params = this.paramsForUrl(url)
        val options = params.routerOptions
        return options!!.callback != null
    }

    /**

     * @param context The context which is spawning the intent
     * *
     * @param url The URL; for example, "users/16" or "groups/5/topics/20"
     * *
     * @return The [Intent] for the url, with the correct [Activity] set, or null.
     */
    fun intentFor(context: Context, url: String): Intent {
        val params = this.paramsForUrl(url)

        return intentFor(context, params)
    }

    private fun intentFor(context: Context, params: RouterParams): Intent? {
        val options = params.routerOptions
        if (options!!.callback != null) {
            return null
        }

        val intent = intentFor(params)
        intent.setClass(context, options.openClass)
        this.addFlagsToIntent(intent, context)
        return intent
    }

    /*
	 * Takes a url (i.e. "/users/16/hello") and breaks it into a {@link RouterParams} instance where
	 * each of the parameters (like ":id") has been parsed.
	 */
    private fun paramsForUrl(url: String): RouterParams {
        val cleanedUrl = cleanUrl(url)

        val parsedUri = URI.create("http://tempuri.org/" + cleanedUrl)

        val urlPath = parsedUri.path.substring(1)

        if (this._cachedRoutes[cleanedUrl] != null) {
            return this._cachedRoutes[cleanedUrl]
        }

        val givenParts = urlPath.split("/".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()

        var routerParams: RouterParams? = null
        for ((key, routerOptions) in this._routes) {
            val routerUrl = cleanUrl(key)
            val routerParts = routerUrl.split("/".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()

            if (routerParts.size != givenParts.size) {
                continue
            }

            val givenParams = urlToParamsMap(givenParts, routerParts) ?: continue

            routerParams = RouterParams()
            routerParams.openParams = givenParams
            routerParams.routerOptions = routerOptions
            break
        }

        if (routerParams == null) {
            throw RouteNotFoundException("No route found for url " + url)
        }

        val query = URLEncodedUtils.parse(parsedUri, "utf-8")

        for (pair in query) {
            routerParams.openParams!!.put(pair.name, pair.value)
        }

        this._cachedRoutes.put(cleanedUrl, routerParams)
        return routerParams
    }

    /**

     * @param givenUrlSegments An array representing the URL path attempting to be opened (i.e. ["users", "42"])
     * *
     * @param routerUrlSegments An array representing a possible URL match for the router (i.e. ["users", ":id"])
     * *
     * @return A map of URL parameters if it's a match (i.e. {"id" => "42"}) or null if there is no match
     */
    private fun urlToParamsMap(givenUrlSegments: Array<String>, routerUrlSegments: Array<String>): MutableMap<String, String>? {
        val formatParams = HashMap<String, String>()
        for (index in routerUrlSegments.indices) {
            val routerPart = routerUrlSegments[index]
            val givenPart = givenUrlSegments[index]

            if (routerPart[0] == ':') {
                val key = routerPart.substring(1, routerPart.length)
                formatParams.put(key, givenPart)
                continue
            }

            if (routerPart != givenPart) {
                return null
            }
        }

        return formatParams
    }

    /**
     * Clean up url
     * @param url
     * *
     * @return cleaned url
     */
    private fun cleanUrl(url: String): String {
        if (url.startsWith("/")) {
            return url.substring(1, url.length)
        }
        return url
    }

    /**
     * Thrown if a given route is not found.
     */
    class RouteNotFoundException(message: String) : RuntimeException(message) {
        companion object {
            private val serialVersionUID = -2278644339983544651L
        }
    }

    /**
     * Thrown if no context has been found.
     */
    class ContextNotProvided(message: String) : RuntimeException(message) {
        companion object {
            private val serialVersionUID = -1381427067387547157L
        }
    }

    companion object {
        private val _router = Router()

        /**
         * A globally accessible Router instance that will work for
         * most use cases.
         */
        fun sharedRouter(): Router {
            return _router
        }
    }
}
